#!/bin/bash
echo $SHELL

# MacOS only
[ -f /opt/homebrew/bin/brew ] && eval "`/opt/homebrew/bin/brew shellenv`"

# zoxide stuff
export PATH=$PATH:$HOME/.local/bin
eval "$(zoxide init zsh)"

export PATH=$PATH:~/.local/bin
export PATH=$PATH:~/.arshan/bin
export PATH=$PATH:/usr/bin

# MacOS specific commands
if [ `uname -s` = "Darwin" ]; then
  alias make="gmake"
  alias sed="gsed"
  alias bazel710=/opt/homebrew/Cellar/bazel/7.1.2/libexec/bin/bazel-7.1.0-darwin-arm64
fi

# MacOS specific commands
if [ `uname -s` = "Linux" ]; then
  alias docker='sudo docker'
  alias kurtosis='sudo kurtosis'
fi

# for all rust programs
source $HOME/.cargo/env

# nvm stuff (imports if exists)
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion


function gitritual() {
  cp ~/.ssh/config.ritual ~/.ssh/config;
  ssh-add -D;
  email="arshan@ritual.net"
  git config --global user.name 'arshan-ritual';
  git config --global user.email $email;
  signing_key=`gpg --list-keys | grep -B 1 $email | head -n 1 | xargs`
  git config --global --replace-all user.signingkey $signing_key;
}

function gitorigin() {
  cp ~/.ssh/config.origin ~/.ssh/config;
  ssh-add -D;
  email="arshan+origin@ritual.net"
  git config --global user.name 'arshan-origin';
  git config --global user.email $email;
  signing_key=`gpg --list-keys | grep -B 1 $email | head -n 1 | xargs`
  git config --global --replace-all user.signingkey $signing_key;
}

function gitpersonal() {
  cp ~/.ssh/config.personal ~/.ssh/config;
  ssh-add -D;
  email="arshankhanifar@gmail.com"
  git config --global user.name 'arshankhanifar';
  git config --global user.email $email;
  signing_key=`gpg --list-keys | grep -B 1 $email | head -n 1 | xargs`
  git config --global --replace-all user.signingkey $signing_key;
}

# suv = start uv
alias suv="command -v conda && conda deactivate; source .venv/bin/activate"

# snuv = "start new uv"
alias snuv="uv venv -p 3.11; command -v conda && conda deactivate; source .venv/bin/activate"

# upip = "uv pip"
alias upip="uv pip"


# emulate linux
function emlinux() {
  image="arshankhanifar/profile:latest"
  if [ -n "$1" ]; then
    image=$1
  fi
  docker run -it --rm -v $(pwd):/home/. -w /home/. --name arshan $image sh -c 'shell=`command -v zsh || command -v bash || command -v sh`; eval $shell'
}

# for some stupid fuckin reason nillion puts their shit in ~/.zshenv
# check if file exists and if so, source it
[ -f ~/.zshenv ] && source ~/.zshenv

alias docrm='docker kill `docker ps -aq` || true && docker rm `docker ps -aq` || true'

function dockill() {
  container_info=`docker container ps | fzf`;
  if [ -z $container_info ]; then
    echo "no container specified";
    return 1;
  fi;
  container_id=`echo $container_info | awk '{print $1}'`;
  docker kill $container_id;
}

# qcom: "this is a quick commit"
function qcom() {
  git commit -am $1
}

# qcomp: "this is a quick commit & push"
function qcomp() {
  git commit -am $1 && git push
}

MACHINE_FILEPATH=`echo ~/remote-machines.txt`

function watchoor() {
  src_path=$1
  ignore_path=$2
  src_path=`pwd`/$src_path
  src_path=`realpath $src_path`
  dirname=`basename $src_path`
  dst_path="~/synced/"

  echo "src_path: $src_path"
  if ! machine=`select_machine`; then return; fi
  keypath=`echo $machine | cut -d ' ' -f1`
  hostname=`echo $machine | cut -d ' ' -f2`

  ssh -i $keypath $hostname "mkdir -p $dst_path"

  always_ignore=".git .venv .idea"

  paths="$ignore_path $EXCLUDE_PATH $always_ignore"

  if [ -f $src_path/.gitignore ] && [ -n "$USE_GITIGNORE" ]; then
    paths+="`cat $src_path/.gitignore | grep -vE '(#|\*|~$)' | tr '\n' ' '`";
  fi;

  excludes=`bash -c '
    excludes=""
    for item in $1; do
      excludes+="--exclude $item "
    done
    echo $excludes
  ' _ "$paths"`

  sync_command="rsync -avz -e \"ssh -i $keypath\" \"$src_path\" $excludes \"$hostname:$dst_path\""

  echo "sync command: 🐸"
  echo $sync_command

  eval $sync_command

  function _sync() {
    fswatch -0 "$src_path" | xargs -0 -n 1 -I {} bash -c '
      function sync_event {
        local src_path=$1
        local keypath=$2
        local hostname=$3
        local dst_path=$4
        local excludes=$5

        echo "Detected change in $src_path"

        sync_command="rsync -avz -e \"ssh -i $keypath\" \"$src_path\" $excludes \"$hostname:$dst_path\""

        eval $sync_command

        echo "Done syncing to $hostname"
      }
      sync_event "$1" "$2" "$3" "$4" "$5"
    ' _ "$src_path" "$keypath" "$hostname" "$dst_path" "$excludes"
  }

  _sync > /dev/null 2>&1 & sync_pid=`expr $! + 2`

  echo "$sync_pid $keypath $hostname $src_path $dst_path " >> ~/watchoors
}

function get_watchoors() {
  cat ~/watchoors
}

function kill_watchoor() {
  watchoor_pid=`get_watchoors | fzf | awk '{print $1}'`
  kill $watchoor_pid
  sed -i "\|^$watchoor_pid|d" ~/watchoors
}

function select_machine() {
  machine=`cat $MACHINE_FILEPATH | fzf`
  if [ -z "$machine" ]; then return 1; fi;
  keyfile=`echo $machine | awk '{print $2}'`
  hostname=`echo $machine | awk '{print $3}'`
  keypath="$keyfile"
  echo "$keypath $hostname"
}

function sshh() {
  if ! machine=`select_machine`; then echo "command was not successful"; return; fi
  keypath=`echo $machine | cut -d ' ' -f1`
  hostname=`echo $machine | cut -d ' ' -f2`
  ssh -o StrictHostKeyChecking=no -i $keypath $hostname
}

function scpull() {
  if ! machine=`select_machine`; then echo "command was not successful"; return; fi
  keypath=`echo $machine | cut -d ' ' -f1`
  hostname=`echo $machine | cut -d ' ' -f2`
  scp -i $keypath $hostname:$1 $2
}

function scpush() {
  if ! machine=`select_machine`; then echo "command was not successful"; return; fi
  keypath=`echo $machine | cut -d ' ' -f1`
  hostname=`echo $machine | cut -d ' ' -f2`
  scp -i $keypath $1 $hostname:$2
}

function poddescribe() {
  line=`kubectl get pods --all-namespaces -o wide | fzf`
  pod=`echo $line | awk '{print $2}'`
  namespace=`echo $line | awk '{print $1}'`
  echo "kubectl describe pod $pod --namespace=$namespace"
  kubectl describe pod $pod --namespace=$namespace
}

function nodedescribe() {
  node=`kubectl get nodes -o wide | fzf | awk '{print $1}'`
  kubectl describe node $node
}

function poddelete() {
  line=`kubectl get pods --all-namespaces -o wide | fzf`
  pod=`echo $line | awk '{print $2}'`
  namespace=`echo $line | awk '{print $1}'`
  kubectl delete pod $pod --namespace=$namespace
}

function delete_service() {
  line=`kubectl get services --all-namespaces -o wide | fzf`
  service=`echo $line | awk '{print $2}'`
  namespace=`echo $line | awk '{print $1}'`
  kubectl delete service $service --namespace=$namespace
}

function delete_node() {
  node=`kubectl get nodes -o wide | fzf |awk '{print $1}'`
  kubectl delete node $node
}

function podlogs() {
  line=`kubectl get pods --all-namespaces -o wide | fzf`
  pod=`echo $line | awk '{print $2}'`
  namespace=`echo $line | awk '{print $1}'`
  kubectl logs $pod -n $namespace "$@";
}

function create_vm() {
  if [ -z "$1" ]; then
    echo "Please provide a machine type"
    return
  fi
	zone_line=`gcloud compute zones list | fzf `;
	zone=`echo $zone_line | awk '{print $1}'`;
	region=`echo $zone_line | awk '{print $2}'`;
	echo "Creating instance in zone: $zone & region: $region";
	instance_name=$(prefix)-$zone;
	output=`gcloud compute instances create $instance_name \
	  --zone=$zone \
	  --machine-type=$1 \
	  --image-family=debian-10 \
	  --image-project=debian-cloud \
	  --tags=http-server`;
	ip=`echo $output | grep RUNNING | awk '{print $5}'`;
	echo "$instance_name gcp-ritual $ip" >> $MACHINE_FILEPATH;
}

function add_to_machine_file() {
  filename=$1
  # note: for looping over space-separated values don't work the same way in zsh,
  # this should work both in bash and zsh
  ip_addresses=(`cat $filename | awk '{print $4}' | tr '\n' ' '`);
  for ip in "${ip_addresses[@]}"; do
    name=`cat $filename | grep $ip | awk '{print $1}'`
    ssh_user=`cat $filename | grep $ip | awk '{print $2}'`
    ssh_key=`cat $filename | grep $ip | awk '{print $3}'`
    sed -i "\|$ip|d" $MACHINE_FILEPATH
    echo "$name $ssh_key $ssh_user@$ip" >> $MACHINE_FILEPATH
  done
}

function add_gcp_vms_to_machine_file() {
  gcloud compute instances list > /tmp/allmachines
  if [ -z "$1" ] && [ "$1" = "auto" ]; then
    cat /tmp/allmachines > /tmp/machines
  else
    cat /tmp/allmachines | fzf -m > /tmp/machines
  fi;
  ip_addresses=`cat /tmp/machines | awk '{print $5}'`
  for ip in $ip_addresses; do
		ssh-keygen -R $ip && ssh-keyscan -H $ip >> ~/.ssh/known_hosts 2>&1 > /dev/null
    sed -i "\|$ip|d" $MACHINE_FILEPATH
  done
  cat /tmp/machines | awk '{print $1 " ~/.ssh/gcp-ritual ritual@" $5}' >> $MACHINE_FILEPATH
  rm /tmp/machines
}

function docsh() {
  container_info=`docker container ps --format "table {{.ID}}\t{{.Names}}\t{{.Image}}" | fzf`
  container_id=`echo $container_info | awk '{print $1}'`
  docker exec -it $container_id /bin/sh
}

function doclogs() {
  container_info=`docker container ps | fzf`
  container_id=`echo $container_info | awk '{print $1}'`
  docker logs -f $container_id
}

function podsh() {
  pod_info=`kubectl get pods --all-namespaces -o wide | fzf`
  pod_name=`echo $pod_info | awk '{print $2}'`
  namespace=`echo $pod_info | awk '{print $1}'`
  kubectl exec -it $pod_name -n $namespace -- /bin/sh
}

function docinspect() {
  container_info=`docker container ls --format "{{.ID}}\t{{.Names}}" | fzf`
  container_id=`echo $container_info | awk '{print $1}'`
  docker inspect $container_id | jq -r '.[0].Config.Cmd'
}

function delete_vm() {
  line=`gcloud compute instances list | fzf`
  instance_name=`echo $line | awk '{print $1}'`
  instance_zone=`echo $line | awk '{print $2}'`
  echo "Deleting instance $instance_name in zone $instance_zone"
  if [ "$1" = "-q" ]; then
    gcloud compute instances delete $instance_name -q --zone=$instance_zone 2>&1 > /dev/null &
  else
    gcloud compute instances delete $instance_name --zone=$instance_zone
  fi
  sed -i "\|$instance_name|d" $MACHINE_FILEPATH
}

